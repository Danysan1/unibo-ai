In the Theory of Computation, a process is taken to be an **algorithm**.

Giving a precise definition of algorithm isn't possible right now. We though want to be sure that we'll be able someday: we'll want to define whether a task can be solved or not with a given algorithm, and to do so, we **have to know what an algorithm is**. We know that algorithms must satisfy some constraints: it must be a finite description of a series of computation steps (maybe parallel, but the description must be finite, i.e. no infinite time to describe it), each step must be elementary (i.e. it must be basic, performable in a finite time), and the next step must always be deterministically determinable (given the state, there can always be found the next step; in other words, the process must be deterministic).

One could say that we could take a program and define it as the description of an algorithm. There's a little problem in this: it is a **very high-level description**, i.e. the instructions are pretty *esoteric*, we don't know what's actually happening under the hood. In this course, we will give a different/abstract/low-level definition.

How can we prove the non-existence of an algorithm to solve a given task? We could start by saying that this is very rarely possible: something can be said/done, but we're still at a point in which the techniques are very few and don't always work. 

## Sets and numbers

In this course, since we're dealing with computation, we might deal with finite or (at most) integer numbers. A condition <img src="svgs/e720ef2e3dc10278f2cc0341a8635074.svg?invert_in_darkmode" align=middle width=35.489081099999986pt height=24.65753399999998pt/> (with <img src="svgs/55a049b8f161ae7cfeb0197d75aff967.svg?invert_in_darkmode" align=middle width=9.86687624999999pt height=14.15524440000002pt/> tipically quite big) holds for a sufficiently large <img src="svgs/55a049b8f161ae7cfeb0197d75aff967.svg?invert_in_darkmode" align=middle width=9.86687624999999pt height=14.15524440000002pt/> if there's <img src="svgs/3d63a7af0e2eca48022ef805461c7fe9.svg?invert_in_darkmode" align=middle width=46.96328504999999pt height=22.648391699999998pt/> such that the condition holds for every <img src="svgs/d6392ebc7d84f8cefd710c3229781dbf.svg?invert_in_darkmode" align=middle width=46.78449764999999pt height=22.465723500000017pt/>, i.e. from given moment it always holds. Let's consider the notation of the *floor function*, i.e. the smallest number of the set such that it is greater than all the elements in the set. We don't use the canonical base for logarithms <img src="svgs/8cd34385ed61aca950a6b06d09fb50ac.svg?invert_in_darkmode" align=middle width=7.654137149999991pt height=14.15524440000002pt/> but <img src="svgs/76c5792347bb90ef71cfbace628572cf.svg?invert_in_darkmode" align=middle width=8.219209349999991pt height=21.18721440000001pt/>.

### Strings

If we fix a finite set, thinking about it as an alphabet, we can form strings over this alphabet as finite or possibly empty tuples. This can also be taken as an alphabet of binary digits. The set of all the strings over a certain alphabet having <img src="svgs/55a049b8f161ae7cfeb0197d75aff967.svg?invert_in_darkmode" align=middle width=9.86687624999999pt height=14.15524440000002pt/> length is indicated as <img src="svgs/13595c3035ea1b1b4d90f5571df51b7c.svg?invert_in_darkmode" align=middle width=19.15340624999999pt height=22.465723500000017pt/>, for example <img src="svgs/f6d56236258d84245467ba9263bef1a4.svg?invert_in_darkmode" align=middle width=17.57992994999999pt height=26.76175259999998pt/> is the set of empty strings. 

The concatenation of two strings <img src="svgs/332cc365a4987aacce0ead01b8bdcc0b.svg?invert_in_darkmode" align=middle width=9.39498779999999pt height=14.15524440000002pt/> and <img src="svgs/deceeaf6940a8c7a5a02373728002b0f.svg?invert_in_darkmode" align=middle width=8.649225749999989pt height=14.15524440000002pt/> is <img src="svgs/65f1b48fb5f326a680b0f7393b9d8b6d.svg?invert_in_darkmode" align=middle width=18.044213549999988pt height=14.15524440000002pt/>. The concatenation by itself is indicated as <img src="svgs/ca258fdb5aa2e16d091da2d680a2bc60.svg?invert_in_darkmode" align=middle width=16.66101689999999pt height=27.91243950000002pt/>. Therefore, strings form a *monoid* (concept of algebra). Note that the neutral element is epsilon. The length is a natural number, indicated as <img src="svgs/b82b509cf285024a5fac5c7a7b0c3e48.svg?invert_in_darkmode" align=middle width=18.52743584999999pt height=24.65753399999998pt/>.

## Tasks

We have formally defined tasks (kind of problems we want to solve by computation devices). We'll take a *standard path* by saying that tasks are functions. We want to compute functions which link a binary set 0,1 to itself, meaning that the domain and codomain are equal to <img src="svgs/7cecc896742e88fdd9f53815dfc26b01.svg?invert_in_darkmode" align=middle width=48.401929949999996pt height=24.65753399999998pt/>.

We don't consider tasks as functions on finite inputs, we just consider an infinite domain: we want to solve a problem not just on a finite amount of instances, but on infinitely many instances. We may want to obtain a string by flipping 0 and 1s, but we'll want to do this on strings of arbitrary length. 

Someone may ask *Well, if we consider a function that maps bitmap images, this has nothing to do with strings!* The point is that strings are a very peculiar discrete set, but they are flexbile enough to be able to represent many other data! When we say that we always assume the task to be given as a function, we're saying that the problem consists in mapping an element of A into an element of B.

 The encoding of any element <img src="svgs/332cc365a4987aacce0ead01b8bdcc0b.svg?invert_in_darkmode" align=middle width=9.39498779999999pt height=14.15524440000002pt/> of <img src="svgs/53d147e7f3fe6e47ee05b88b166bd3f6.svg?invert_in_darkmode" align=middle width=12.32879834999999pt height=22.465723500000017pt/> as a string is often indicated as \_x_.

Suppose that the strings in <img src="svgs/0e9acb8e323d122fa04eea6eb4e79496.svg?invert_in_darkmode" align=middle width=17.76257669999999pt height=22.63846199999998pt/> are composed of elements of <img src="svgs/47eeffd75bb9bee2e18bc685105e9ebf.svg?invert_in_darkmode" align=middle width=86.85295244999999pt height=24.65753399999998pt/>. Now, <img src="svgs/44bc9d542a92714cac84e01cbbb7fd61.svg?invert_in_darkmode" align=middle width=8.68915409999999pt height=14.15524440000002pt/> can be encoded as <img src="svgs/59ce7cb36c53da540aad87f0ce12cd22.svg?invert_in_darkmode" align=middle width=16.438418699999993pt height=21.18721440000001pt/>, <img src="svgs/4bdc8d9bcfb35e1c9bfb51fc69687dfc.svg?invert_in_darkmode" align=middle width=7.054796099999991pt height=22.831056599999986pt/> becomes <img src="svgs/2a8dfa554b06260e6dd6ed4a6440c0fe.svg?invert_in_darkmode" align=middle width=16.438418699999993pt height=21.18721440000001pt/> and <img src="svgs/3e18a4a28fdee1744e5e3f79d13b9ff6.svg?invert_in_darkmode" align=middle width=7.11380504999999pt height=14.15524440000002pt/> becomes <img src="svgs/b0c08f9b595a704efb907fc688034d80.svg?invert_in_darkmode" align=middle width=16.438418699999993pt height=21.18721440000001pt/>.

Now, what happens if we start to construct more complex domains, like couples of strings? For example,  

Another interesting class of functions is the one in which the length of the strings is exactly one: **boolean functions**.
These are also known as *characteristic functions*, and they are related to decision problems because, for example, in these we'll want to decide whether a string is good/bad, part of a set/not...

Asymptotic notation is not about a function or the other, rather about the kind of functions we take as limits on the amount of resources we want to devote to solving a particular problem. We are now concerned with functions dedicated to natural numbers.
Let's consider another function <img src="svgs/3cf4fbd05970446973fc3d9fa3fe3c41.svg?invert_in_darkmode" align=middle width=8.430376349999989pt height=14.15524440000002pt/>, we want to compare them as per their rate of growth. We'd like to be able to say if <img src="svgs/190083ef7a1625fbc75f243cffb9c96d.svg?invert_in_darkmode" align=middle width=9.81741584999999pt height=22.831056599999986pt/> grows faster than <img src="svgs/3cf4fbd05970446973fc3d9fa3fe3c41.svg?invert_in_darkmode" align=middle width=8.430376349999989pt height=14.15524440000002pt/>, asymptotically speaking.
If a function <img src="svgs/190083ef7a1625fbc75f243cffb9c96d.svg?invert_in_darkmode" align=middle width=9.81741584999999pt height=22.831056599999986pt/> is <img src="svgs/27e556cf3caa0673ac49a8f0de3c73ca.svg?invert_in_darkmode" align=middle width=8.17352744999999pt height=22.831056599999986pt/> of <img src="svgs/3cf4fbd05970446973fc3d9fa3fe3c41.svg?invert_in_darkmode" align=middle width=8.430376349999989pt height=14.15524440000002pt/>, it grows (asymptotically speaking) in the same way.

So, showing that two functions <img src="svgs/190083ef7a1625fbc75f243cffb9c96d.svg?invert_in_darkmode" align=middle width=9.81741584999999pt height=22.831056599999986pt/> and <img src="svgs/3cf4fbd05970446973fc3d9fa3fe3c41.svg?invert_in_darkmode" align=middle width=8.430376349999989pt height=14.15524440000002pt/> are comparable, is made by studying the limit of the ratio <img src="svgs/f869e40b6a66cf16557a28095139cb6c.svg?invert_in_darkmode" align=middle width=26.099919449999998pt height=33.20539859999999pt/> for <img src="svgs/219ed870532672193ea4f5955e8b4de4.svg?invert_in_darkmode" align=middle width=51.87587954999999pt height=14.15524440000002pt/> and proving that it is constant. 

#
[Previous section](0%20-%20LAAI%20-%20Module%203%20Intro.md) Â· [Next section](2%20-%20The%20computational%20model.md)


