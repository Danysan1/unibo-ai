# FAIKR 4 Summary

## Forward and Backward Reasoning

Rule-based forward reasoning is a way to deduce (create) some new knowledge starting from a set of facts using some rules.
On the other hand, backward reasoning starts from a goal and checks if the goal holds given the premises.

## Logic programming

### Prolog

#### Cut

The **cut (`;`)** doesn't have any logical meaning or declarative semantics.
It makes the choices that the program took non-backtrackable and is used to make permanent all choices made on the line.
```prolog
p :- q_1, q_2, ..., q_i, !, q_i+1, q_i+2, ..., q_n
```
If the evaluation of `q_i+1, q_i+2, ..., q_n` fails, the whole `p` fails: even if there are alternatives for `p`, they have been removed by the cut.

#### Meta-predicates

- **`call(T)`:** prolog evaluates the predicate `T`
- **`fail`:** each evaluation of this fails. This forces the program to look for alternatives.
- **`not(P)`/`\+(P)`:** true if `P` is not a consequence
- **`setof(X,P,S)`:** S is the set of instances `X` that satisfy `P`
- **`bagof(X,P,L)`:** L is the list of instances `X` that satisfy `P`
- **`findall(X,P,S)`:** S is the set of terms `X` that satisfy the `P`
- **`clause(Head, Body)`:** true if there exists such a clause with head `Head` and `Body`

#### Meta-interpreter

Vanilla meta-interpreter:
```prolog
solve(true) :- !. % solves predicates that are explicitly present in the KB
solve((A,B)) :- !, solve(A), solve(B). % decomposes a goal into subgoals and solves them
solve(A) :- clause(A,B), solve(B). % checks the presence of a clause with head A and solves its body B
```

#### Negation

SLDNF is an extension of SLD used in Prolog to implement the Negation as Failure.
Once we have variables in our goal, SLDNF is not safe anymore, hence Prolog implementation is not completely correct.
**In Prolog we should apply negation only to ground facts**, the negation of `X` is written as `~X`.

## Probabilistic logic programming

### LPAD

TODO

## Production rule systems

Production rule systems extend logical based forward reasoning allowing us to explicitly have side effects in the RHS, like printing out things or calling procedures.
The knowledge base is stored in the working memory and can be edited retracting/adding facts (unlike backward reasoning, where a full re-computation is needed to keep logical consistency, only some rules need to be applied in a order that must be chosen).

### RETE

RETE is the fastest algorithm for production rule system algorithm.
It expects LHS to be conjunction of patterns on facts and it avoids the iteration over facts by storing, for each pattern, the facts that the pattern matches with.
Patterns can test two types of features:
- intra-elements: tests on the new fact or on data inside the new fact.
- inter-elements: tests on conditions between different facts/patterns.

For example in "When there are a student named X and a professor named X do...", "student" and "professor" are intra-element while "both named X" is inter-element.

### Drools

TODO

## Complex Event Processing

Each **simple event** detected by the system includes an information payload and a temporal extent.
**Complex events** are generated by the system (not necessarily mapped to simple events), contain a more informative payload and always have a durative temporal extent.
CEP framework includes 
- Complex Events Definition
- Complex Event Recognition Module: management of filtering, analysis and deletion of simple events in a timely manner.
- Input simple events and output complex events

Typical approaches are based on automata (e.g. regex), trees o logic rules.

### Event Calculus Framework


Event Calculus Framework is a logic based approach for CEP and is used to deal with properties whose truthness value changes over time (**fluents**).
It uses some predicates (such as `HoldsAt(Fluent,Time)`, `Happens(Event,Time)`, `Initiates(Event,Fluent,Time)`, ...) to check if some fluents hold (or some events happen) at specific moments.
It is easily implementable in Prolog but it would not safe if fluents/events contain variables (due to Prolog implementation of Negation).
