# Knowledge representation

The idea here is using knowledge to solve problems. What is this knowledge we're talking about? We can talk about **declarative knowledge** and **imperative knowledge**. We can describre a problem using both of them. 

KR is the area if AI concerned with how **knowledge can be represented symbolically** and manipulated in an automated way by reasoning programs.

We therefore have a language (symbolic representation) and the concept of  **knolwedge base**, i.e. a set of sentences (**clauses**) encoded in a given KR language that describe a given domain/problem, a subset of the world.

The semantics are usually related to a notion of **truth**. When we write a sentence we have an idea of what we are writing: this is linked to **semantics**, i.e. the meaning of clauses. When talking about Prolog, the sentences have a formal semantic, but we can even talk about *informal semantics*. Most of the tools we use today have **formal semantics** though.

Another important concept is the **expressive power**, which is not trivial: if you take programming languages, you are able to know what they can compute. In KR this concept is not true: there are different KR *methods* having different expressive power. 

When you think about KR, sometimes, some authors speak about *knowledge level*, i.e. the top level of languages, where we only describe knowledge using some kind of symbolic language. Its syntax is quite common. 

AI languages like Prolog have an active interpreter, are dynamic languages (think about meta-programming, and the fact that we have to dynamically check the type of things). Another important point is the support of **symbols** and **terms** as first class objects, meaning that you have a category of the language that allows these. This is true both for LISP and PROLOG. The last property (only holding for these languages) is the fact that the data are equivalent to programs, giving us a high-level of flexibility (meta-interpreters!). This means that we can trasform code as we transform data!

Just a low percentage of programmers use these languages. *This is a problem.* (no?)

Sometimes when using these languages we don't solve everything we need, but we can rely on other tools, like Java, remote procedure calls, web services...

## LISP

What we'll do from now on is **LISP**. 

```lisp
(defun factorial (n)
  (if (<= n 1)
      1
      (* n (factorial (- n 1)))))
```

LISP is also known as *List of Inutili Stupid Parenthesis*. And that may be about right, diocristo.

### How does a KR language work?

The Knowledge Base is feeded to the inference engine, which analyses goals. The speed of the engine is expressed in *inferences per second*, and the capacity as *number of clauses*. 

Then, what is an **inference engine**? It's a tool that, given precondition/actions rules is able to perform reasoning. 

A reasoning process could be monotonic or not. We want to see how this ind of reasoning process goes on, and with which properties. The properties, related to the KB, depend on the inference engine. 

What are the most important? **Soundness** first of all, i.e. if what we put in the KB is true, the new clauses generated by the engine shall be true too. The other important property is **completeness**, i.e. the engine, given the KB, is able to deduct **all** the true clauses. It should be powerful enough to compute everything that is needed.

There are then other properties concerning the goal, first of all **decidability**, i.e. the fact that we'll reach or not a conclusion. Finally, **efficiency**.

There's an important tradeoff concerning **efficiency** and the **capacity of representing things**. These two sides basically represent *what we knoe can be represented as comprehensibly as possible* and *what we know can be reasoned as effectively as possible*. 





